---
title: "Graphs SF Bay Summer 2022"
author: "Annika Nazanin"
date: "`r {Sys.Date()}`"
format: html
---

## DEFINE Globals

### Scenario and lever

```{r}
category <- "Transit"
lever <- "Frequency"
year <- "2018"
```

### File name

#### Look on AWS

```{r set_aws_params}
library(aws.s3)
library(dbplyr) # to get from aws
aws_prefix <- "deepDive/CleanData/SanFrancisco"
Sys.setenv("AWS_DEFAULT_REGION"="us-east-2")
awsDF <- get_bucket_df("beam-core-act", prefix = aws_prefix) # bucket directory
```

```{r aws_data_file_list, include=FALSE}
# We want stacked dataset for these graphs
data_file_list_paths_chrACTUAL <- awsDF$Key[grep(pattern = "*.tacked*", awsDF$Key)]
data_file_list_paths_chrACTUAL
```

####CHANGE

```{r}
file_to_use <- "deepDive/CleanData/SanFrancisco/Stacked/sf_2018_stacked_tr_fr_v4.csv" 
```

#### Define the path file in separate R file

```{r define_paths, include=FALSE}
source( paste0(getwd(),
        "/2022_06_14_global_file_directories.R") )
# returns: 
print(data_dir_on_this_machine)
print(output_dir_on_this_machine)
figures_folder <- paste0(output_dir_on_this_machine,"figures")
print(figures_folder)
```

### Y variables:

```{r echo=FALSE}
listY <- list("Potential_INEXUS_in_dollar","duration_door_to_door")
print(listY)
```

### Heterogeneity variables:

```{r g_Het_WithinScenario, echo=FALSE}
# With imap, going through a list using a |> , .x is the thing in the list, and .y is the name of the thing in the list.  So like, .x is each dataframe in the list, and .y is the name of the dataframe in the list. The other way is    map2( .x = df_in_a_list, .y = names(df_in_a_list), ~fx_H...
listHet       <- list("ownCarYNLabel", "l_inc_HiLo10")
# listHetFilter <- list(df_in_a_list, data_inc_HiLo10)
print(listHet)
```

### Should we save graphs right now?

```{r TFsave_graphs, include=FALSE}
saveGraphsTF = TRUE
```

## Setup

### Library

```{r, include=FALSE}
# library(tikzDevice) # to get really really good looking things use dev tikz
library(kableExtra)
library(Cairo)
library(tinytex)
library(reader)
# cairo_null_device(4, 3.2)
library(flextable)
# library(magick)
library(readr)
library(aws.s3)
library(dbplyr) # to get from aws
# library(purrr)
library(khroma) 
library(patchwork)
library(flexdashboard)
library(ggridges)
library(ggExtra) # marginal plots
library(ggrepel) # make labels not overlap
# library(cowplot) 
library(stringr)
library(scales)
# library(plotly) # make interactive!
# library(Hmisc)
library(stargazer)
library(svglite)
library(dplyr)
library(tidyverse)
library(ggplot2)
# library(gghighlight)    # highlight one part of plot
# library(usethis)
gc()
```

### Graphics device test of graphic size and dpi

Make sure width and size are consistent with what i see. This is what I see in the
GUI, and\
mmmmmThis text is two inches:

```{r TEST, echo=FALSE}
df <- tibble::tribble( ~x, ~y, ~name,
  1,  1,  "12pt font",
  3,  3,  "f",
  2,  2,  "This text is two inches")
OneInchInmm <- 25.4
mmOf12ptFont <- 12 / .pt
device.size.px <- dev.size(units="px")
device.size.in <- dev.size(units="in")
device.size.px.per.in <- dev.size("px")/dev.size("in")


# Test graph
ggplot(df, aes(x = x, y = y, label = name)) +
  geom_text(size = mmOf12ptFont) +
  geom_point(size = mmOf12ptFont, shape = 7) +
  geom_point(size = 2*OneInchInmm, shape = 7) +
  theme( plot.title = element_text(size = 12)) +
  # The graph title has info about the size of the graphics in it
  labs(title = paste(
  "This text is two inches 
[IT IS 12 POINT FONT][which is 12char per inch]
---size of text and points within the graph is in mm, .pt is a var in ggplot
---where the mm are font size / .pt, so for font size 12, mm are", 12/.pt,"mm.
---the boxes are two inches, which is 2 times 12 /.pt,",12/.pt,"mm.
[This PLOT SIZE IS probably 7.3 WIDTH, 4.5 HEIGHT:
---- ",dev.size("in")[1],"by", dev.size("in")[2],"same as",device.size.in[1],device.size.in[2],"
[device size pixels rstudio, and for rendered:",dev.size("px")[1],"by",dev.size("px")[2],device.size.px[1],device.size.px[2],"
[furthermore if you set the break at 48 columns'][then this is 4in and, total is 8 inches across]
---Pix per inch:", dev.size("px")/dev.size("in"),"or", device.size.px.per.in,". range:", par("usr"),   par("usr")[c(2,4)] - par("usr")[c(1,3)],
"---Pct devoted to plot:", par("plt")[c(2,4)] - par("plt")[c(1,3)][1],par("plt")[c(2,4)] - par("plt")[c(1,3)][2],
"
[This text is     [this's one]               This text is two inches", 
""))   +
  labs(x = "Culmen Length (mm)")
# [Number of pixels per plot inch x and y: ",dev.size(units="px") * par("plt")[c(2,4)] - par("plt")[c(1,3)] / (par("usr")[c(2,4)] - par("usr")[c(1,3)])[1],"
# --Plot size:", dev.size(units="in") * par("plt")[c(2,4)] - par("plt")[c(1,3)][1],dev.size(units="in") * par("plt")[c(2,4)] - par("plt")[c(1,3)][2],
ggsave(filename = paste0("test.svg"), path = figures_folder, width  = dev.size("in")[1], height = dev.size("in")[2])
ggsave(filename = paste0("test.png"), path = figures_folder, width  = dev.size("in")[1], height = dev.size("in")[2])
ggsave(filename = paste0("test.pdf"), path = figures_folder, width  = dev.size("in")[1], height = dev.size("in")[2])
rm(df)
```

This is the pdf version, and\
mmmmmThis text is two inches:

![](output/figures/test.pdf)

This is the png version, and\
mmmmmThis text is two inches:

![](output/figures/test.png)

This is the svg version, and\
mmmmmThis text is two inches:

![](output/figures/test.svg)

## Open data and summarize

### Dataset

```{r open_files}
df_stacked_from_list   <- read_rds(file =
            paste0(data_dir_on_this_machine,
                   "df_stacked_from_list3.rds"))
#                    "df_stacked_from_list_small.rds"))
  # df_stacked_from_list <-
  #   aws.s3::s3read_using(read_csv,
  #                        object = file_to_use,
  #                        bucket = "beam-core-act")

```

### Key description file

```{r open_files}
description_df   <- read_csv(file ="ScenarioTitlesColorsEtc.csv")
```

### Variables

```{r}
names(df_stacked_from_list)
```

### Clean

!!!! NEED TO MAKE A SHORTENED LIST WITH FEWER VARIABLES BUT THEY DONT MATCH MINE

```{r}

df_stacked_from_list <-   df_stacked_from_list |> 
  mutate(across(where(is.character), as_factor))

  df_stacked_from_list <- df_stacked_from_list %>%
    mutate(income10levels = ntile(income_in_thousands,10))  %>%  
    mutate(ownCarYNLabel = 
           case_when(auto_ownership >= 1 ~ "Owns Car",
                     auto_ownership == 0 ~ "Does not own Car"
                     )  )
  
#   df_stacked_from_list <- df_stacked_from_list %>%
#     select(-c(contains("fuel"),
#              SEX,	DIS,	VEH,	DRIVEALONEFREE,	DRIVEALONEPAY,
# SHARED2PAY,	SHARED3FREE,	SHARED3PAY,	WALK,	BIKE,
# WALK_LRF,	WALK_EXP,	WALK_HVY,	WALK_COM,	DRIVE_LOC,
# DRIVE_EXP,	DRIVE_HVY,	DRIVE_COM	, TAXI,	
# 
# 
# TNC_SINGLE
#                ))
  
  # df_stacked_from_list <- df_stacked_from_list |> 
  #   mutate(logsum_trip_mode_AS_trips = Potential_INEXUS_in_dollar)
  # select(IDMerged,
  #        person_id,
  #        trip_id,
  #        home_is_urban,
  #        auto_ownership,
  #        income_in_thousands,
  #        # earning,
  #        hh_value_of_time,
  #        median_value_of_time,
  #        value_of_time,
  #        actEndTime,
  #        actStartTime,
  #        # travelTime,
  #        waitTime,
  #        # roundtrip_auto_time_to_school,
  #        # roundtrip_auto_time_to_work,
  #        starts_with("duration"),
  #        # actPurpose,
  #        # mandatoryType,
  #        income10levels,
  #        # incomeLow30Label,
  #        # incomeLoHi10Lab,
  #        # ownCarYNLabel,
  #        # scenShort,
  #        # scenYear,
  #        lever_position,
  #        # category,
  #        lever,
  #        # scenYr,
  #        # scenPl,
  #        # scenBind,
  #        # num_young_children,
  #        # Potential_INEXUS_in_dollar
  # )

```

### Scenarios

```{r}
  # print(levels(df_stacked_from_list$scenShort))
  print(levels(as_factor(df_stacked_from_list$lever_position)))
  print(levels(df_stacked_from_list$lever))
  # print(levels(df_stacked_from_list$category))
```

## Define Labels, Titles, Other

Here we modify the csv sheet

### Titles of Graphs

### Labels of variables

```{r fx_LABELS, echo=FALSE}
fx_LABELS <- function(x) {
  x <- x %>%
    mutate(
      l_inc_HiLo10 =
        case_when(
          income10levels == 1 ~ "Lowest 10% Inc ",
          income10levels == 10 ~ "Highest 10% Income ",
          TRUE ~ "Middle 80% Income"
        )
    )
  return(x)
}

# RUN FUNCTION
# df_in_a_list <- map(df_in_a_list, ~ fx_LABELS(.))
# df_merged_from_list <- fx_LABELS(df_merged_from_list)
df_stacked_from_list <- fx_LABELS(df_stacked_from_list)
```

### Limits of y variables, scales

```{r}
description_df <- description_df |>
  mutate(
    yaxislow =
      case_when(
        variable == "Potential_INEXUS_in_dollar" ~
          median_hilow(df_stacked_from_list$Potential_INEXUS_in_dollar, 
                       conf.int =                         .95)[["ymin"]],
        variable == "duration_door_to_door" ~          0
      ),
    yaxishigh =
      case_when(
        variable == "Potential_INEXUS_in_dollar" ~
          median_hilow(df_stacked_from_list$Potential_INEXUS_in_dollar, 
                       conf.int =
                         .95)[["ymax"]],
        variable == "duration_door_to_door" ~
          median_hilow(df_stacked_from_list$duration_door_to_door, conf.int =
                         .90)[["ymax"]]
        
      ),
    yaxismedian =
      case_when(
        variable == "Potential_INEXUS_in_dollar" ~
          median_hilow(df_stacked_from_list$Potential_INEXUS_in_dollar, conf.int =
                         .95)[["y"]],
        variable == "duration_door_to_door" ~
          median_hilow(df_stacked_from_list$duration_door_to_door, conf.int =
                         .95)[["y"]]
      )
  )
```

### Colors

#### for divergent

```{r}
color_baseline <- "#EAECCC"
color_transitFreq50p <- "#FDB366"
color_lower_than_baseline <- "#ee3377" # magenta
color_higher_than_baseline <- "#33bbee" # cyan opposite of magenta
color_higher_than_baseline <- "#0077bb" # darker blue

```

#### for the modes

```{r}
# color_scheme_df <- names(df_in_a_list)

description_df <- description_df  %>% 
  mutate(colorOfScenario = case_when(
    str_detect(name_df,"base") ~ color_baseline ,
    str_detect(name_df,"rh") ~ "#ee7733",
    str_detect(name_df,"fq") ~ "#009988",
    str_detect(name_df,"rh") ~ "#0077bb",
    str_detect(name_df,"fq") ~ "#009988"
    
    ) ) |> 
  mutate(alphaOfScenario = lever_position)
print(description_df)

```

### Themes

```{r}
theme_set(theme_light(base_size = 11)) # make ALL font based on this
theme_update(plot.title = element_text(face = "bold"),
             legend.justification = "center",
             legend.position = "bottom",
             legend.title = element_blank(),
             legend.text  = element_text(face = "green") +
               scale_color_vibrant() +
               scale_fill_vibrant()  
)
```

## Summary stats

### quantiles mean median

```{r }
fx_SUMMARY_STATS <- function(df) {
  print(levels(as_factor(df_stacked_from_list$lever_position)))
  print(fct_unique(as_factor(df_stacked_from_list$lever_position)))
  print(levels(df_stacked_from_list$scenShort))
  print(fct_unique(df_stacked_from_list$Short))
  sssumm <- df %>%
    group_by(lever_position) |> 
    summarise(
      avLS = mean(.data[["Potential_INEXUS_in_dollar"]]),
      avY = mean(.data[["Potential_INEXUS_in_dollar"]]), 
      n=n()
    )
  print(sssumm)
  sssummQuantiles <- df %>%
    group_by(lever_position) |> 
    summarise(
      avLS = mean(.data[["Potential_INEXUS_in_dollar"]]),
      avY = mean(.data[["Potential_INEXUS_in_dollar"]]), 
      qsLS=quantile(.data[["Potential_INEXUS_in_dollar"]]),
      qsTIV=quantile(.data[["Potential_INEXUS_in_dollar"]], na.rm = TRUE),
      n=n()
    )
  print(sssummQuantiles)
  return(c(sssumm, sssummQuantiles))
}

fx_SUMMARY_STATS(df_stacked_from_list)
```

## START THE GRAPHS!

## LOOP ACROSS Y VARS and Heterogeneity

### Across

```{r}
fx_Het_AcrossScenario <- function(df, y_var, het = "none",
                                  nm = "", tit = "noTitle", 
                                  ...) {
  yvarTitle <- filter(description_df,variable == y_var)[["Title"]]
  plotttaaaa0 <- ggplot() +
# Now usual
    coord_cartesian(xlim = c(
    filter(description_df, variable == y_var)[["yaxislow"]],
    filter(description_df, variable == y_var)[["yaxishigh"]])) +
    # TITLE
    labs(title = str_glue("{year} {category} {lever}"),
           subtitle = str_glue("Examine {yvarTitle}, with heterogeneity across: {het}")
      ) +
    xlab(filter(description_df, variable == y_var)[["Title"]]) +
    ylab(" density ") 
# facet wrap LEVER
  plottttt <- plotttaaaa0 +
    geom_density(
      data = df ,
        aes(
          x = .data[[y_var]],
          fill = .data[[het]],
          color = .data[[het]],
          group = .data[[het]]
      ),
      alpha = .3
    )    +
    facet_wrap(df_stacked_from_list$lever_position, ncol = 3)
    print(plottttt)
    if(saveGraphsTF == TRUE) {
         ggsave(str_glue("figures/{Sys.Date()}_{nm}_{y_var}_{het}_{category}_wrap-{lever}_{year}.png"))
         ggsave(str_glue("figures/{Sys.Date()}_{nm}_{y_var}_{het}_{category}_wrap-{lever}_{year}.pdf"))
    }
# facet wrap HET    
  plottttt <- plotttaaaa0 +
    geom_density(
      data = df ,
        aes(
          x = .data[[y_var]],
          fill =  .data[["lever_position"]],
          # alpha = .data[["lever_position"]]*.1,
          color = .data[["lever_position"]],
          group = .data[["lever_position"]]
      )
      ,
      alpha = .1
        
    )    +
    facet_wrap(facets = df_stacked_from_list$ownCarYNLabel , ncol = 3) 
    print(plottttt)
    if(saveGraphsTF == TRUE) {
         ggsave(str_glue("figures/{Sys.Date()}_{nm}_{y_var}_wrap-{het}_{category}_{lever}_{year}.png"))
         ggsave(str_glue("figures/{Sys.Date()}_{nm}_{y_var}_wrap-{het}_{category}_{lever}_{year}.pdf"))
    }
return(plottttt)
}

 g_het_loop_across <- map(
   .x = listY,
   ~ map2(
     .x = .x,
     .y = listHet,
     ~ fx_Het_AcrossScenario(
       df = df_stacked_from_list,
       y_var = .x,
       het = .y,
       nm = "HetAcross"
     )
   )
 )
 g_het_loop_across
```
